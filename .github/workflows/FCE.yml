name: Firmware Extraction

on:
  workflow_dispatch:
    inputs:
      url:
        required: true
        description: 'Firmware ZIP URL'
      track:
        required: false
        description: 'Tracking ID'
      image_type:
        required: true
        default: 'boot'
        description: 'boot/recovery/modem'

env:
  SEARCH_PATHS: ". firmware-update firmware images radio"
  MAX_RETRIES: 3
  RETRY_DELAY: 10

jobs:
  check_duplicate:
    name: Check for Duplicate Runs
    runs-on: ubuntu-latest
    outputs:
      should_continue: ${{ steps.check_duplicate.outputs.should_continue }}
    steps:
      - name: Check for existing runs
        id: check_duplicate
        run: |
          # GitHub API ile aynı firmware için aktif run kontrolü
          response=$(curl -s -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" \
            -H "Accept: application/vnd.github+json" \
            "https://api.github.com/repos/${{ github.repository }}/actions/runs?status=in_progress")
          
          # jq ile aynı URL ve image_type için aktif run var mı kontrol et
          duplicate_exists=$(echo "$response" | jq --arg url "${{ inputs.url }}" \
            --arg type "${{ inputs.image_type }}" \
            '.workflow_runs[] | select(.inputs.url == $url and .inputs.image_type == $type) | .id' | wc -l)
          
          if [ "$duplicate_exists" -gt 0 ]; then
            echo "::warning::Duplicate run detected for ${{ inputs.image_type }} image"
            echo "should_continue=false" >> $GITHUB_OUTPUT
          else
            echo "should_continue=true" >> $GITHUB_OUTPUT
          fi

  extract:
    name: Extract ${{ inputs.image_type }}
    needs: check_duplicate
    if: needs.check_duplicate.outputs.should_continue == 'true'
    runs-on: ubuntu-latest
    timeout-minutes: 60

    steps:
      - name: Validate Inputs
        run: |
          if [[ ! "${{ inputs.url }}" =~ \.zip($|\?) ]]; then
            echo "::error::Invalid URL pattern"
            exit 1
          fi
          echo "Processing ${{ inputs.image_type }} image from ${{ inputs.url }}"
          echo "Track ID: ${{ inputs.track || 'N/A' }}"

      - uses: actions/checkout@v4

      - name: Setup Environment
        run: |
          # Gerekli paketleri kur
          sudo apt-get update -qq
          sudo apt-get install -y \
            android-sdk-libsparse-utils \
            p7zip-full \
            aria2 \
            brotli \
            python3-pip \
            jq \
            curl

          # simg2img için sembolik link
          sudo ln -sf /usr/lib/android-sdk/libsparse-utils/simg2img /usr/local/bin/

          # Payload dumper kurulumu
          if [ ! -d "tools" ]; then
            git clone https://github.com/vm03/payload_dumper.git tools
          fi

          # Python bağımlılıkları
          pip install -q protobuf pyelftools
          echo "Environment setup completed"

      - name: Download Firmware
        run: |
          for i in $(seq 1 $MAX_RETRIES); do
            if aria2c -x 8 -s 8 --out=firmware.zip "${{ inputs.url }}"; then
              echo "Download completed successfully"
              break
            fi
            
            if [ $i -eq $MAX_RETRIES ]; then
              echo "::error::Download failed after $MAX_RETRIES attempts"
              exit 1
            fi
            
            echo "Attempt $i failed, retrying in $RETRY_DELAY seconds..."
            sleep $RETRY_DELAY
          done

      - name: Extract Files
        run: |
          mkdir -p extracted
          7z x firmware.zip -oextracted -y
          rm -f firmware.zip
          echo "Extracted files structure:"
          find extracted -type f | head -n 20

      - name: Process Images
        id: process
        run: |
          cd extracted
          rom_name=$(basename "${{ inputs.url }}" .zip)
          output_file="${{ inputs.image_type }}_${rom_name}.zip"
          mkdir -p ../release
          
          declare -A file_patterns=(
            ["boot"]="boot.img"
            ["recovery"]="recovery.img"
            ["modem"]="NON-HLOS.bin md1img.img modem.bin modem.img"
          )

          # Tüm dizinlerde arama
          found_file=""
          for path in $SEARCH_PATHS; do
            [ ! -d "$path" ] && continue
            for pattern in ${file_patterns[${{ inputs.image_type }}]}; do
              file_path="$path/$pattern"
              if [ -f "$file_path" ]; then
                echo "Found $file_path"
                7z a "../release/$output_file" "$file_path"
                found_file="$file_path"
                break 2
              fi
            done
          done

          # Payload.bin fallback
          if [ -z "$found_file" ] && [ -f "payload.bin" ]; then
            echo "Extracting from payload.bin..."
            python3 ../tools/payload_dumper.py --out . --images "${{ inputs.image_type }}"* payload.bin
            
            for pattern in ${file_patterns[${{ inputs.image_type }}]}; do
              if [ -f "$pattern" ]; then
                echo "Found extracted $pattern"
                7z a "../release/$output_file" "$pattern"
                found_file="$pattern"
                break
              fi
            done
          fi

          if [ -z "$found_file" ]; then
            echo "::error::No ${{ inputs.image_type }} files found in: ${file_patterns[${{ inputs.image_type }}]}"
            exit 1
          fi

          echo "output_file=$output_file" >> $GITHUB_OUTPUT
          echo "Processed $found_file successfully"

      - name: Upload Release
        uses: softprops/action-gh-release@v1
        with:
          tag_name: auto
          files: release/${{ steps.process.outputs.output_file }}
          draft: false
          prerelease: false
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Cleanup
        if: always()
        run: |
          rm -rf extracted release
          echo "Cleanup completed"

      - name: Update KV Store
        if: success()
        run: |
          # Cloudflare KV'yi güncellemek için ek API çağrısı
          curl -X PUT "https://api.cloudflare.com/client/v4/accounts/$CF_ACCOUNT_ID/storage/kv/namespaces/$KV_NAMESPACE_ID/values/${{ inputs.image_type }}:${{ inputs.track }}" \
            -H "Authorization: Bearer $CF_API_TOKEN" \
            -H "Content-Type: application/json" \
            --data '{"status":"completed"}'
        env:
          CF_ACCOUNT_ID: ${{ secrets.CF_ACCOUNT_ID }}
          KV_NAMESPACE_ID: ${{ secrets.KV_NAMESPACE_ID }}
          CF_API_TOKEN: ${{ secrets.CF_API_TOKEN }}
