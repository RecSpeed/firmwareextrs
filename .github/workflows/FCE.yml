name: Enhanced Firmware Extraction

on:
  workflow_dispatch:
    inputs:
      url:
        required: true
        description: 'Firmware ZIP URL'
      firmware_name:
        required: true
        description: 'Firmware Base Name (without .zip)'
      track:
        required: false
        description: 'Tracking ID'
      image_type:
        required: true
        default: 'boot'
        description: 'boot/recovery/modem/system_ext'

concurrency:
  group: extract-${{ inputs.image_type }}-${{ inputs.firmware_name }}
  cancel-in-progress: true

jobs:
  extract:
    runs-on: ubuntu-latest
    timeout-minutes: 60

    steps:
      - name: Check inputs
        run: |
          echo "Processing ${{ inputs.image_type }} from ${{ inputs.url }}"
          echo "Firmware Name: ${{ inputs.firmware_name }}"
          echo "Track ID: ${{ inputs.track || 'None' }}"

      - name: Setup environment
        run: |
          sudo apt-get update
          sudo apt-get install -y \
            android-sdk-libsparse-utils \
            p7zip-full \
            aria2 \
            brotli \
            python3-pip
          sudo ln -sf /usr/lib/android-sdk/libsparse-utils/simg2img /usr/local/bin/
          
          # Install payload_dumper and erofs-utils
          git clone https://github.com/vm03/payload_dumper.git tools
          aria2c -o erofs-utils.zip https://github.com/sekaiacg/erofs-utils/releases/download/v1.8.1-240810/erofs-utils-v1.8.1-gddbed144-Linux_x86_64-2408101422.zip
          7z x erofs-utils.zip -otools
          pip install -r ./tools/requirements.txt protobuf pyelftools bsdiff4 telethon==1.28.5
          rm -f erofs-utils.zip

      - name: Download firmware
        run: |
          aria2c -x 8 -s 8 --out=firmware.zip "${{ inputs.url }}" || exit 1
          [ -f firmware.zip ] || (echo "Download failed" && exit 1)

      - name: Extract files
        run: |
          7z x firmware.zip -oextracted -y
          rm -f firmware.zip

      - name: Find and package image
        id: process
        run: |
          cd extracted
          output_file="${{ inputs.image_type }}_${{ inputs.firmware_name }}.zip"
          
          # Partition mapping
          case "${{ inputs.image_type }}" in
            boot) patterns="boot.img"; payload_partition="boot" ;;
            recovery) patterns="recovery.img"; payload_partition="recovery" ;;
            modem) patterns="NON-HLOS.bin md1img.img modem.bin modem.img"; payload_partition="modem" ;;
            system_ext) patterns="system_ext.img"; payload_partition="system_ext" ;;
            vendor_boot) patterns="vendor_boot.img"; payload_partition="vendor_boot" ;;
            init_boot) patterns="init_boot.img"; payload_partition="init_boot" ;;
          esac
          
          # Önce direkt dosya arama
          found=false
          for pattern in $patterns; do
            file=$(find . -iname "$pattern" | head -n 1)
            if [ -f "$file" ]; then
              [ "${{ inputs.image_type }}" = "system_ext" ] && handle_system_ext "$file" || 7z a "../$output_file" "$file"
              found=true
              break
            fi
          done
          
          # Eğer dosya bulunamazsa ve payload.bin varsa
          if [ "$found" = false ] && [ -f "payload.bin" ]; then
            echo "Sadece $payload_partition partition'ını çıkarıyorum..."
            
            # payload_dumper.py'yi doğru şekilde çağır
            if python3 ../tools/payload_dumper.py --images "$payload_partition" payload.bin; then
              for pattern in $patterns; do
                file=$(find . -iname "$pattern" | head -n 1)
                if [ -f "$file" ]; then
                  [ "${{ inputs.image_type }}" = "system_ext" ] && handle_system_ext "$file" || 7z a "../$output_file" "$file"
                  found=true
                  break
                fi
              done
            else
              echo "::error::Payload dumper failed to extract $payload_partition"
              exit 1
            fi
          fi
          
          if [ "$found" = false ]; then
            echo "::error::İstenen ${{ inputs.image_type }} image dosyası bulunamadı"
            exit 1
          fi
          echo "file_name=$output_file" >> $GITHUB_OUTPUT

        env:
          # System_ext işleme fonksiyonu
          handle_system_ext: |
            sudo mkdir -p /mnt/priv-app/Settings && sudo chmod -R 777 /mnt
            7z x "$1" -o/mnt -y && sudo cp /mnt/priv-app/Settings/Settings.apk . && echo "method 1 used" || \
            (../tools/extract.erofs -i "$1" -x -o . && cp system_ext/priv-app/Settings/Settings.apk . && echo "method 2 used" || \
            (echo "both methods failed" && exit 1))
            7z a "../$output_file" Settings.apk

      - name: Upload release
        if: success()
        uses: softprops/action-gh-release@v1
        with:
          tag_name: auto
          files: ${{ steps.process.outputs.file_name }}
          draft: false
          prerelease: false

      - name: URL Encode KV Key
        id: urlencode
        run: |
          # KV key format: "<image_type>:<firmware_name>"
          key="${{ inputs.image_type }}:${{ inputs.firmware_name }}"
          encoded=$(python3 -c "import urllib.parse; print(urllib.parse.quote('''$key'''))")
          echo "encoded=$encoded" >> $GITHUB_OUTPUT
          
      - name: Validate Secrets
        run: |
         if [ -z "${{ secrets.CF_API_TOKEN }}" ]; then
         echo "::error::Cloudflare API Token tanımlı değil!"
         echo "Lütfen GitHub Repository Settings > Secrets bölümünden CF_API_TOKEN ekleyin"
         exit 1
         fi
    
         if [ -z "${{ secrets.CF_ACCOUNT_ID }}" ]; then
         echo "::error::Cloudflare Account ID tanımlı değil!"
         exit 1
         fi
    
          if [ -z "${{ secrets.CF_NAMESPACE_ID }}" ]; then
          echo "::error::Cloudflare Namespace ID tanımlı değil!"
          exit 1
         fi
    
      - name: Update KV on Success
        if: success()
        run: |
          key="${{ inputs.image_type }}:${{ inputs.firmware_name }}"
          timestamp=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
          data="{\"state\": \"complete\", \"timestamp\": \"$timestamp\", \"error\": null, \"file\": \"${{ steps.process.outputs.file_name }}\"}"
          echo "Updating KV record for key $key with value $data"
          curl -X PUT "https://api.cloudflare.com/client/v4/accounts/${{ secrets.CF_ACCOUNT_ID }}/storage/kv/namespaces/${{ secrets.CF_NAMESPACE_ID }}/values/${{ steps.urlencode.outputs.encoded }}" \
            -H "Authorization: Bearer ${{ secrets.CF_API_TOKEN }}" \
            -H "Content-Type: application/json" \
            --data "$data"

      - name: Update KV on Failure
        if: failure()
        run: |
          # API yetkilendirmesini kontrol et
          if [ -z "${{ secrets.CF_API_TOKEN }}" ]; then
            echo "::error::Cloudflare API token bulunamadı!"
            exit 1
          fi

          key="${{ inputs.image_type }}:${{ inputs.firmware_name }}"
          timestamp=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
          
          # Hata detayını al
          error_msg=$(sed -n '/::error::/ s/.*::error::\(.*\)/\1/p' "$GITHUB_STEP_SUMMARY" | tail -1 || echo "Extraction failed")
          
          data="{\"state\": \"failed\", \"timestamp\": \"$timestamp\", \"error\": \"$error_msg\", \"tracking_url\": \"$GITHUB_SERVER_URL/$GITHUB_REPOSITORY/actions/runs/$GITHUB_RUN_ID\"}"
          
          echo "Updating KV record for key $key with value: $data"
          
          response=$(curl -sS -X PUT \
            "https://api.cloudflare.com/client/v4/accounts/${{ secrets.CF_ACCOUNT_ID }}/storage/kv/namespaces/${{ secrets.CF_NAMESPACE_ID }}/values/${{ steps.urlencode.outputs.encoded }}" \
            -H "Authorization: Bearer ${{ secrets.CF_API_TOKEN }}" \
            -H "Content-Type: application/json" \
            --data "$data")
          
          if ! echo "$response" | grep -q '"success":true'; then
            echo "::error::KV güncelleme başarısız: $response"
            # Fallback olarak GitHub'a hata yaz
            echo "FAILED: $data" >> $GITHUB_STEP_SUMMARY
            exit 1
          fi
      
      - name: Cleanup
        if: always()
        run: rm -rf extracted tools
